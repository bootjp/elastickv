package distribution

import (
	"bytes"
	"sort"
	"sync"
	"sync/atomic"
)

// Route represents a mapping from a key range to a raft group.
// Ranges are right half-open intervals: [Start, End). Start is inclusive and
// End is exclusive. A nil End denotes an unbounded interval extending to
// positive infinity.
type Route struct {
	// Start marks the inclusive beginning of the range.
	Start []byte
	// End marks the exclusive end of the range. nil means unbounded.
	End []byte
	// GroupID identifies the raft group for the range starting at Start.
	GroupID uint64
	// Load tracks the number of accesses served by this range.
	Load uint64
}

// Engine holds in-memory metadata of routes and provides timestamp generation.
type Engine struct {
	mu               sync.RWMutex
	routes           []Route
	ts               uint64
	hotspotThreshold uint64
}

// NewEngine creates an Engine with no hotspot splitting.
func NewEngine() *Engine {
	return NewEngineWithThreshold(0)
}

// NewEngineWithThreshold creates an Engine and sets a threshold for hotspot
// detection. A non-zero threshold enables automatic range splitting when the
// number of accesses to a range exceeds the threshold.
func NewEngineWithThreshold(threshold uint64) *Engine {
	return &Engine{routes: make([]Route, 0), hotspotThreshold: threshold}
}

// UpdateRoute registers or updates a route for the given key range.
// Routes are stored sorted by Start.
func (e *Engine) UpdateRoute(start, end []byte, group uint64) {
	e.mu.Lock()
	defer e.mu.Unlock()
	e.routes = append(e.routes, Route{Start: start, End: end, GroupID: group})
	sort.Slice(e.routes, func(i, j int) bool {
		return bytes.Compare(e.routes[i].Start, e.routes[j].Start) < 0
	})
}

// GetRoute finds a route for the given key using right half-open intervals.
func (e *Engine) GetRoute(key []byte) (Route, bool) {
	e.mu.RLock()
	defer e.mu.RUnlock()
	idx := e.routeIndex(key)
	if idx < 0 {
		return Route{}, false
	}
	return e.routes[idx], true
}

// NextTimestamp returns a monotonic increasing timestamp.
func (e *Engine) NextTimestamp() uint64 {
	return atomic.AddUint64(&e.ts, 1)
}

// RecordAccess increases the access counter for the range containing key and
// splits the range if it turns into a hotspot. The load counter is updated
// atomically under a read lock to allow concurrent access recording. If the
// hotspot threshold is exceeded, RecordAccess acquires a full write lock and
// re-checks the condition before splitting to avoid races with concurrent
// splits.
func (e *Engine) RecordAccess(key []byte) {
	e.mu.RLock()
	idx := e.routeIndex(key)
	if idx < 0 {
		e.mu.RUnlock()
		return
	}
	load := atomic.AddUint64(&e.routes[idx].Load, 1)
	threshold := e.hotspotThreshold
	e.mu.RUnlock()
	if threshold == 0 || load < threshold {
		return
	}

	e.mu.Lock()
	defer e.mu.Unlock()
	idx = e.routeIndex(key)
	if idx < 0 {
		return
	}
	if e.routes[idx].Load >= threshold {
		e.splitRange(idx)
	}
}

// Stats returns a snapshot of current ranges and their load counters.
func (e *Engine) Stats() []Route {
	e.mu.RLock()
	defer e.mu.RUnlock()
	stats := make([]Route, len(e.routes))
	for i, r := range e.routes {
		stats[i] = Route{Start: cloneBytes(r.Start), End: cloneBytes(r.End), GroupID: r.GroupID, Load: atomic.LoadUint64(&e.routes[i].Load)}
	}
	return stats
}

func (e *Engine) routeIndex(key []byte) int {
	if len(e.routes) == 0 {
		return -1
	}
	i := sort.Search(len(e.routes), func(i int) bool {
		return bytes.Compare(e.routes[i].Start, key) > 0
	})
	if i == 0 {
		return -1
	}
	i--
	r := e.routes[i]
	if r.End != nil && bytes.Compare(key, r.End) >= 0 {
		return -1
	}
	return i
}

func (e *Engine) splitRange(idx int) {
	r := e.routes[idx]
	if r.End == nil {
		// cannot split unbounded range; reset load to avoid repeated attempts
		e.routes[idx].Load = 0
		return
	}
	mid := midpoint(r.Start, r.End)
	if mid == nil {
		// cannot determine midpoint; reset load to avoid repeated attempts
		e.routes[idx].Load = 0
		return
	}
	left := Route{Start: r.Start, End: mid, GroupID: r.GroupID}
	right := Route{Start: mid, End: r.End, GroupID: r.GroupID}
	// replace the range at idx with left and right in an idiomatic manner
	e.routes = append(e.routes[:idx+1], e.routes[idx:]...)
	e.routes[idx] = left
	e.routes[idx+1] = right
}

func cloneBytes(b []byte) []byte {
	if b == nil {
		return nil
	}
	out := make([]byte, len(b))
	copy(out, b)
	return out
}

// midpoint returns a key that is lexicographically between a and b. It returns
// nil if such a key cannot be determined (e.g. a and b are too close).
func midpoint(a, b []byte) []byte {
	m := append(cloneBytes(a), 0)
	if bytes.Compare(m, b) >= 0 {
		return nil
	}
	return m
}
